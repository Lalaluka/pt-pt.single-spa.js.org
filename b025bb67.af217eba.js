(window.webpackJsonp=window.webpackJsonp||[]).push([[145],{272:function(e,t,o){"use strict";o.r(t),o.d(t,"frontMatter",(function(){return r})),o.d(t,"rightToc",(function(){return s})),o.d(t,"default",(function(){return p}));var a=o(1),n=o(9),i=(o(0),o(360)),r={id:"recommended-setup",title:"The Recommended Setup",sidebar_label:"Overview"},s=[{value:"Overview",id:"overview",children:[]},{value:"Alternatives",id:"alternatives",children:[]},{value:"In-browser versus build-time modules",id:"in-browser-versus-build-time-modules",children:[]},{value:"Import Maps",id:"import-maps",children:[]},{value:"SystemJS",id:"systemjs",children:[]},{value:"Lazy loading",id:"lazy-loading",children:[]},{value:"Local development",id:"local-development",children:[]},{value:"Build tools (Webpack / Rollup)",id:"build-tools-webpack--rollup",children:[]},{value:"Utility modules (styleguide, API, etc)",id:"utility-modules-styleguide-api-etc",children:[]},{value:"Shared dependencies",id:"shared-dependencies",children:[]},{value:"Deployment and Continuous Integration (CI)",id:"deployment-and-continuous-integration-ci",children:[]},{value:"Applications versus parcels versus utility modules",id:"applications-versus-parcels-versus-utility-modules",children:[]},{value:"Inter-app communication",id:"inter-app-communication",children:[{value:"Functions, components, logic, and environment variables",id:"functions-components-logic-and-environment-variables",children:[]},{value:"API Data",id:"api-data",children:[]},{value:"UI State",id:"ui-state",children:[]}]},{value:"State management",id:"state-management",children:[]}],l={rightToc:s},c="wrapper";function p(e){var t=e.components,o=Object(n.a)(e,["components"]);return Object(i.b)(c,Object(a.a)({},l,o,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,'The single-spa npm package is not opinionated about your build tools, CI process, or local development workflow. However, to implement single-spa you will have to figure all of those things out (and more). To help you decide how to approach these problems, the single-spa core team has put together a "recommended setup" that gives an opinionated approach to solving the practical problems of microfrontends.'),Object(i.b)("h2",{id:"overview"},"Overview"),Object(i.b)("p",null,"We recommend a setup that uses in-browser ES modules + import maps (or SystemJS to polyfill these if you need better browser support). This setup has several advantages:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Common libraries are easy to manage, and are only downloaded once. If you're using SystemJS, you can also preload them for a speed boost as well."),Object(i.b)("li",{parentName:"ol"},"Sharing code / functions / variables is as easy as import/export, just like in a monolithic setup"),Object(i.b)("li",{parentName:"ol"},"Lazy loading applications is easy, which enables you to speed up initial load times"),Object(i.b)("li",{parentName:"ol"},"Each application (AKA microservice, AKA ES module) can be independently developed and deployed. Teams are enabled to work at their own speed, experiment (within reason as defined by the organization), QA, and deploy on thier own schedules. This usually also means that release cycles can be decreased to days instead of weeks or months"),Object(i.b)("li",{parentName:"ol"},"A great developer experience (DX): go to your dev environment and add an import map that points the application's url to your localhost. See sections below for details")),Object(i.b)("h2",{id:"alternatives"},"Alternatives"),Object(i.b)("p",null,Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/umijs/qiankun"}),"qiankun")," is a popular alternative to this recommended setup."),Object(i.b)("h2",{id:"in-browser-versus-build-time-modules"},"In-browser versus build-time modules"),Object(i.b)("p",null,"Tutorial video: ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.youtube.com/watch?v=Jxqiu6pdMSU&list=PLLUD8RtHvsAOhtHnyGx57EYXoaNsxGrTU&index=2"}),"Youtube")," / ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.bilibili.com/video/av83498486/"}),"Bilibili")),Object(i.b)("p",null,"An in-browser javascript module is when imports and exports are not compiled away by your build tool, but instead are\nresolved within the browser. This is different from build-time modules, which are supplied by your node_modules and\ncompiled away before they touch the browser."),Object(i.b)("p",null,"The way to tell webpack and rollup to leave some dependencies untouched during the build, so that they come from the browser,\nis via ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://webpack.js.org/configuration/externals/#root"}),"webpack externals")," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://rollupjs.org/guide/en/#external"}),"rollup externals"),"."),Object(i.b)("p",null,"Here are our recommendations:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Each single-spa application should be an in-browser Javascript module."),Object(i.b)("li",{parentName:"ol"},"Large shared dependencies (ie, the react, vue, or angular libraries) should each be in-browser modules."),Object(i.b)("li",{parentName:"ol"},"Everything else should be a build-time module.")),Object(i.b)("h2",{id:"import-maps"},"Import Maps"),Object(i.b)("p",null,"Tutorial video: ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.youtube.com/watch?v=Lfm2Ge_RUxs&list=PLLUD8RtHvsAOhtHnyGx57EYXoaNsxGrTU&index=3"}),"Youtube")," / ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.bilibili.com/video/av83617496/"}),"Bilibili")),Object(i.b)("p",null,Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/WICG/import-maps"}),"Import Maps"),' are a browser specification for aliasing "import specifiers" to a URL.\nAn import specifier is the string indicating which module to load. Examples:'),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"// ./thing.js is the import specifier\nimport thing from './thing.js';\n\n// react is the import specifier\nimport React from 'react';\n")),Object(i.b)("p",null,'Specifiers that are not a URL are called "bare specifiers," such as ',Object(i.b)("inlineCode",{parentName:"p"},"import 'react'"),". Being able to alias bare specifiers to a URL\nis crucial to being able to use in-browser modules, which is why import maps exist."),Object(i.b)("p",null,"As of Feb 2020, import maps are only implemented in Chrome, and behind a developer feature toggle. As such, you will need a polyfill\nto make import maps work."),Object(i.b)("h2",{id:"systemjs"},"SystemJS"),Object(i.b)("p",null,"Tutorial video: ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.youtube.com/watch?v=AmdKF2UhFzw&list=PLLUD8RtHvsAOhtHnyGx57EYXoaNsxGrTU&index=7"}),"Youtube")," / ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.bilibili.com/video/av83620028/"}),"Bilibili")),Object(i.b)("p",null,"SystemJS provides polyfill-like behavior for import maps and in-browser modules. It is not a true polyfill of import maps, due to limitations of the javascript language in polyfilling the resolution of bare import specifiers to URLs."),Object(i.b)("p",null,"Since SystemJS is only polyfill-like, you'll need to compile your applications into ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/systemjs/systemjs/blob/master/docs/system-register.md"}),"System.register format")," instead of to ESM format. This allows for in-browser modules to be fully emulated in environments that don't support modules or import maps."),Object(i.b)("p",null,"To compile your code to System.register format, set webpack's ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://webpack.js.org/configuration/output/#outputlibrarytarget"}),Object(i.b)("inlineCode",{parentName:"a"},"output.libraryTarget"))," to ",Object(i.b)("inlineCode",{parentName:"p"},'"system"'),", or set rollup's ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://rollupjs.org/guide/en/#outputformat"}),Object(i.b)("inlineCode",{parentName:"a"},"format"))," to ",Object(i.b)("inlineCode",{parentName:"p"},'"system"'),"."),Object(i.b)("p",null,"Shared dependencies like React, Vue, and Angular, do not publish System.register versions of their libraries. However, you can find System.register versions of the libraries in ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/esm-bundle"}),"the esm-bundle project")," (",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://medium.com/@joeldenning/an-esm-bundle-for-any-npm-package-5f850db0e04d"}),"blog post"),"). Alternatively, SystemJS is capable of loading them via ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/systemjs/systemjs#2-systemjs-loader"}),"global loading")," or ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/systemjs/systemjs#extras"}),"the AMD and named-exports extras"),"."),Object(i.b)("p",null,"An alternative to SystemJS that provides polyfill behavior for import maps is ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/guybedford/es-module-shims"}),"es-module-shims"),". This has the advantage of using truly native ES modules. However, it is not the single-spa core team's recommended approach for production applications, since it requires less-performant in browser parsing and modification of all your bundles."),Object(i.b)("h2",{id:"lazy-loading"},"Lazy loading"),Object(i.b)("p",null,"Tutorial video: ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.youtube.com/watch?v=-LkvBMpCK-A&list=PLLUD8RtHvsAOhtHnyGx57EYXoaNsxGrTU&index=8"}),"Youtube")," / ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.bilibili.com/video/av83620658/"}),"Bilibili")),Object(i.b)("p",null,"Lazy loading is when you only download javascript code that the user needs for the current page, instead of all javascript upfront. It is a technique for improving the performance of your application by decreasing the time-to-meaningful-render when you initially load the page. If you use ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/configuration#loading-function-or-application"}),"single-spa loading functions"),', you already have built-in lazy loading for your applications and parcels. Since an application is an "in-browser module," this means that you are only downloading the in-browser modules in your import map when you need them.'),Object(i.b)("p",null,'Often, the route-based lazy loading provided by single-spa loading functions is all that you need to ensure great performance. However, it is also possible to do lazy loading via "code splits" with your bundler (webpack or rollup). For documentation on webpack code splits, see ',Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://webpack.js.org/guides/code-splitting/#dynamic-imports"}),"these docs"),". It is recommended to use dynamic import (",Object(i.b)("inlineCode",{parentName:"p"},"import()"),") instead of multiple entry points for code splits in a single-spa application. For code splits to work properly, you'll need to ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://webpack.js.org/guides/public-path/#on-the-fly"}),"dynamically set your public path"),". A tool exists to help you set your public path correctly for use with systemjs - ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/joeldenning/systemjs-webpack-interop"}),"https://github.com/joeldenning/systemjs-webpack-interop"),"."),Object(i.b)("p",null,"Lazy loading is when you only download javascript code that the user needs for the current page, instead of all javascript upfront. It is a technique for improving the performance of your application by decreasing the time-to-meaningful-render when you initially load the page. If you use ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/configuration#loading-function-or-application"}),"single-spa loading functions"),', you already have built-in lazy loading for your applications and parcels. Since an application is an "in-browser module," this means that you are only downloading the in-browser modules in your import map when you need them.'),Object(i.b)("p",null,'Often, the route-based lazy loading provided by single-spa loading functions is all that you need to ensure great performance. However, it is also possible to do lazy loading via "code splits" with your bundler (webpack or rollup). For documentation on webpack code splits, see ',Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://webpack.js.org/guides/code-splitting/#dynamic-imports"}),"these docs"),". It is recommended to use dynamic import (",Object(i.b)("inlineCode",{parentName:"p"},"import()"),") instead of multiple entry points for code splits in a single-spa application. For code splits to work properly, you'll need to ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://webpack.js.org/guides/public-path/#on-the-fly"}),"dynamically set your public path"),". A tool exists to help you set your public path correctly for use with systemjs - ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/joeldenning/systemjs-webpack-interop"}),"https://github.com/joeldenning/systemjs-webpack-interop"),"."),Object(i.b)("h2",{id:"local-development"},"Local development"),Object(i.b)("p",null,"Tutorial video: ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.youtube.com/watch?v=vjjcuIxqIzY&list=PLLUD8RtHvsAOhtHnyGx57EYXoaNsxGrTU&index=4"}),"Youtube")," / ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.bilibili.com/video/av83617789/"}),"Bilibili")),Object(i.b)("p",null,"In contrast to monolithic frontend applications, local development with single-spa encourages only running the one microfrontend you're working on, while using deployed versions of all other microfrontends. This is important because running every single-spa microfrontend every time you want to do anything is unwieldy and cumbersome."),Object(i.b)("p",null,"To accomplish local development of only one microfrontend at a time, we can customize the URL for that microfrontend within the import map. For example, the following import map is set up for local development of the ",Object(i.b)("inlineCode",{parentName:"p"},"navbar")," application, since that's the only one pointing to a local web server. The ",Object(i.b)("inlineCode",{parentName:"p"},"planets")," and ",Object(i.b)("inlineCode",{parentName:"p"},"things")," applications are pointing to deployed (already hosted) versions of the applications."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{\n  "imports": {\n    "@react-mf/navbar": "https://localhost:8080/react-mf-navbar.js",\n    "@react-mf/planets": "https://react.microfrontends.app/planets/2717466e748e53143474beb6baa38e3e5320edd7/react-mf-planets.js",\n    "@react-mf/things": "https://react.microfrontends.app/things/7f209a1ed9ac9690835c57a3a8eb59c17114bb1d/react-mf-things.js"\n  }\n}\n')),Object(i.b)("p",null,"A tool called ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/joeldenning/import-map-overrides"}),"import-map-overrides")," exists to customize your import map through an in-browser UI. This tool will automatically let you toggle one or more microfrontends between your localhost and the deployed version."),Object(i.b)("p",null,'Additionally, you have the choice of running your single-spa root config locally, or using the single-spa config that is running on a deployed environment. The single-spa core team finds it easiest to develop on deployed environments (perhaps an "integration", "development", or "staging" environment that is running within your organization) so that you do you not have to constantly run your single-spa root config.'),Object(i.b)("p",null,"In contrast to monolithic frontend applications, local development with single-spa encourages only running the one microfrontend you're working on, while using deployed versions of all other microfrontends. This is important because running every single-spa microfrontend every time you want to do anything is unwieldy and cumbersome."),Object(i.b)("p",null,"To accomplish local development of only one microfrontend at a time, we can customize the URL for that microfrontend within the import map. For example, the following import map is set up for local development of the ",Object(i.b)("inlineCode",{parentName:"p"},"navbar")," application, since that's the only one pointing to a local web server. The ",Object(i.b)("inlineCode",{parentName:"p"},"planets")," and ",Object(i.b)("inlineCode",{parentName:"p"},"things")," applications are pointing to deployed (already hosted) versions of the applications."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{\n  "imports": {\n    "@react-mf/navbar": "https://localhost:8080/react-mf-navbar.js",\n    "@react-mf/planets": "https://react.microfrontends.app/planets/2717466e748e53143474beb6baa38e3e5320edd7/react-mf-planets.js",\n    "@react-mf/things": "https://react.microfrontends.app/things/7f209a1ed9ac9690835c57a3a8eb59c17114bb1d/react-mf-things.js"\n  }\n}\n')),Object(i.b)("p",null,"A tool called ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/joeldenning/import-map-overrides"}),"import-map-overrides")," exists to customize your import map through an in-browser UI. This tool will automatically let you toggle one or more microfrontends between your localhost and the deployed version."),Object(i.b)("p",null,'Additionally, you have the choice of running your single-spa root config locally, or using the single-spa config that is running on a deployed environment. The single-spa core team finds it easiest to develop on deployed environments (perhaps an "integration", "development", or "staging" environment that is running within your organization) so that you do you not have to constantly run your single-spa root config.'),Object(i.b)("h2",{id:"build-tools-webpack--rollup"},"Build tools (Webpack / Rollup)"),Object(i.b)("p",null,"Tutorial video: ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.youtube.com/watch?v=I6COIg-2lyM&list=PLLUD8RtHvsAOhtHnyGx57EYXoaNsxGrTU&index=9"}),"Youtube")," / ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.bilibili.com/video/av84104639/"}),"Bilibili")),Object(i.b)("p",null,"It is highly encouraged to use a bundler such as webpack, rollup, parceljs, pikapack, etc. Webpack is an industry-standard for compiling many javascript source files into one or more production javascript bundles."),Object(i.b)("p",null,"Below are some tips for configuring your bundler to be consumable by SystemJS and single-spa. Note that if you're using ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/create-single-spa"}),"create-single-spa")," that these are all set up for you. We leave these instructions here not to overwhelm you with webpack configuration hell, but rather to help you if you choose not to use create-single-spa."),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Set the output target to ",Object(i.b)("inlineCode",{parentName:"li"},"system"),". In webpack, this is done via ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://webpack.js.org/configuration/output/#outputlibrarytarget"}),Object(i.b)("inlineCode",{parentName:"a"},"output.libraryTarget"))),Object(i.b)("li",{parentName:"ol"},"Use a single ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://webpack.js.org/concepts/entry-points/#root"}),"entry point"),", with ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://webpack.js.org/guides/code-splitting/#dynamic-imports"}),"dynamic imports"),' for any code splitting that you\'d like to accomplish. This best matches the "one bundled project = one in-browser module" paradigm encouraged by the single-spa core team.'),Object(i.b)("li",{parentName:"ol"},"Do not use webpack's ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://webpack.js.org/configuration/optimization/#root"}),Object(i.b)("inlineCode",{parentName:"a"},"optimization"))," configuration options, as they make it harder to load the outputted javascript files as a single in-browser javascript module. Doing so does not make your bundle less optimized - dynamic imports are a viable strategy for accomplishing optimized bundles."),Object(i.b)("li",{parentName:"ol"},"Follow ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/systemjs/systemjs#compatibility-with-webpack"}),"the systemjs docs for webpack"),"."),Object(i.b)("li",{parentName:"ol"},"Consider using ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/joeldenning/systemjs-webpack-interop"}),"systemjs-webpack-interop")," to create or verify your webpack config."),Object(i.b)("li",{parentName:"ol"},"Use ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/joeldenning/systemjs-webpack-interop"}),"systemjs-webpack-interop")," to ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://webpack.js.org/guides/public-path/#on-the-fly"}),'set your webpack public path "on the fly"'),"."),Object(i.b)("li",{parentName:"ol"},"Do not set webpack ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://webpack.js.org/configuration/output/#outputlibrary"}),Object(i.b)("inlineCode",{parentName:"a"},"output.library")),". SystemJS does not need a name, and in fact does not support named modules without additional configuration."),Object(i.b)("li",{parentName:"ol"},"Consider turning off ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://webpack.js.org/configuration/output/#outputfilename"}),"webpack hashing")," for both entry and code split bundles. It is often easier to add in a commit hash during deployment of your microfrontend via your CI environment variables."),Object(i.b)("li",{parentName:"ol"},"Configure webpack-dev-server to not do host checks. (",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://webpack.js.org/configuration/dev-server/#devserverdisablehostcheck"}),"docs"),")."),Object(i.b)("li",{parentName:"ol"},"Configure webpack-dev-server for CORS by setting ",Object(i.b)("inlineCode",{parentName:"li"},"{headers: {'Access-Control-Allow-Origin': '*'}}"),". (",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://stackoverflow.com/questions/31602697/webpack-dev-server-cors-issue"}),"docs"),")"),Object(i.b)("li",{parentName:"ol"},"If developing on https, ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://webpack.js.org/configuration/dev-server/#devserverhttps"}),"configure webpack-dev-server for HTTPS"),". Also consider ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://stackoverflow.com/questions/7580508/getting-chrome-to-accept-self-signed-localhost-certificate"}),"trusting SSL certificates from localhost"),"."),Object(i.b)("li",{parentName:"ol"},"Make sure that your ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://webpack.js.org/configuration/externals/#root"}),"webpack externals")," are correctly configured for any shared, in-browser modules that you are importing."),Object(i.b)("li",{parentName:"ol"},"Set ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://webpack.js.org/configuration/output/#outputjsonpfunction"}),"output.jsonpFunction")," to be a unique string for this project. Since you'll have multiple webpack bundles running in the same browser tab, a collision of the ",Object(i.b)("inlineCode",{parentName:"li"},"jsonpFunction")," could result in webpack modules getting mixed between bundles."),Object(i.b)("li",{parentName:"ol"},"Set ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://webpack.js.org/configuration/dev-server/#devserversockport"}),"sockPort"),", ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://webpack.js.org/configuration/dev-server/#devserversockpath"}),"sockPath"),", and ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://webpack.js.org/configuration/dev-server/#devserversockhost"}),"sockHost")," inside of your ",Object(i.b)("inlineCode",{parentName:"li"},"devServer")," configuration.")),Object(i.b)("p",null,"For a bit more information specific to webpack code splits, see ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/faq#code-splits"}),"the code splits FAQ"),"."),Object(i.b)("h2",{id:"utility-modules-styleguide-api-etc"},"Utility modules (styleguide, API, etc)"),Object(i.b)("p",null,'A "utility module" is an in-browser javascript module that is not a single-spa application or parcel. In other words, it\'s only purpose is to export functionality for other microfrontends to import.'),Object(i.b)("p",null,"Common examples of utility modules include styleguides, authentication helpers, and API helpers. These modules do not need to be registered with single-spa, but are important for maintaining consistency between several single-spa applications and parcels."),Object(i.b)("p",null,"Example code in a utility module:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'// In a repo called "api", you may export functions from the repo\'s entry file.\n// These functions will be available to single-spa application, parcels, and other in-browser modules\n// via an import statement.\n\nexport function authenticatedFetch(url, init) {\n  return fetch(url, init).then(r => {\n    // Maybe do some auth stuff here\n    return r.json()\n  })\n}\n')),Object(i.b)("p",null,"Example code in a single-spa application that is using the utility module:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"// Inside of a single-spa application, you can import the functions from the 'api' repo\nimport React from 'react'\nimport { authenticatedFetch } from '@org-name/api';\n\nexport function Foo(props) {\n  React.useEffect(() => {\n    const abortController = new AbortController()\n    authenticatedFetch(`/api/clients/${props.clientId}`, {signal: abortController.signal})\n    .then(client => {\n      console.log(client)\n    })\n\n    return () => {\n      abortController.abort()\n    }\n  }, [props.clientId])\n\n  return null\n}\n")),Object(i.b)("p",null,"To make utility modules work, you must ensure that your webpack externals and import map are properly configured. An example of a working styleguide may be found at ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/vue-microfrontends/styleguide"}),"https://github.com/vue-microfrontends/styleguide"),"."),Object(i.b)("h2",{id:"shared-dependencies"},"Shared dependencies"),Object(i.b)("p",null,"For performance, it is crucial to only load large javascript libraries a single time. Your framework of choice (React, Vue, Angular, etc) should only be loaded on the page a single time."),Object(i.b)("p",null,"It is not advisable to make everything a shared dependency, because shared dependencies must be upgraded at once for every microfrontend that uses them. For small libraries, it is likely acceptable to duplicate them in each repository that uses them. For example, react-router is likely small enough to duplicate, which is nice when you want to upgrade your routing one microfrontend at a time. However, for large libraries like react, momentjs, rxjs, etc, you may consider making them shared dependencies."),Object(i.b)("p",null,"To accomplish this, you should use ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://webpack.js.org/configuration/externals/#root"}),"webpack externals"),", ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://rollupjs.org/guide/en/#external"}),"rollup externals"),", or similar. Marking libraries as external tells your bundler to not use the version in your node_modules, but rather to expect the library to exist as an in-browser module."),Object(i.b)("p",null,"To make the shared dependencies available as in-browser modules, they must be present in your import map. A good way of managing them is to create a repository called ",Object(i.b)("inlineCode",{parentName:"p"},"shared-dependencies")," that has a partial import map in it. The CI process for that repository updates your deployed import map. Upgrading the shared dependencies can then be achieved by making a pull request to that repository."),Object(i.b)("p",null,"Not all libraries publish their code in a suitable format for SystemJS consumption. In those cases, check ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/esm-bundle"}),"https://github.com/esm-bundle")," for a SystemJS version of those libraries. Alternatively, you may use ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/systemjs/systemjs#extras"}),"SystemJS extras")," to support UMD bundles, which are often available."),Object(i.b)("p",null,"An example of a shared-dependencies repo, along with a functioning CI process for it, can be found at ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/polyglot-microfrontends/shared-dependencies"}),"https://github.com/polyglot-microfrontends/shared-dependencies"),"."),Object(i.b)("h2",{id:"deployment-and-continuous-integration-ci"},"Deployment and Continuous Integration (CI)"),Object(i.b)("p",null,"Tutorial video (Part 1): ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.youtube.com/watch?v=QHunH3MFPZs&list=PLLUD8RtHvsAOhtHnyGx57EYXoaNsxGrTU&index=5"}),"Youtube")," / ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.bilibili.com/video/av84100303/"}),"Bilibili")),Object(i.b)("p",null,"Tutorial video (Part 2): ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.youtube.com/watch?v=nC7rpDXa4B8&list=PLLUD8RtHvsAOhtHnyGx57EYXoaNsxGrTU&index=6"}),"Youtube")," / ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.bilibili.com/video/av84099642/"}),"Bilibili")),Object(i.b)("p",null,Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/single-spa/import-map-deployer/tree/master/examples"}),"Example CI configuration files")),Object(i.b)("p",null,"Microfrontends are built and deployed completely independently. This means that the git repository, CI, build, and deployments all occur without going through a centralized repository. For this reason, monorepos are not encouraged for microfrontends since monorepos may only have one CI for all of the packages in the repo."),Object(i.b)("p",null,"There are two steps to deploying a microfrontend."),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Uploading production javascript bundles to a web server / CDN. It is encouraged to use a CDN such as AWS S3 + Cloudfront, Google Cloud Storage, Microsoft Azure Storage, Digital Ocean Spaces, etc because of their superior availability, caching, and performance due to edge locations. The javascript files that you upload are completely static. It is encouraged to always write new files to the CDN instead of overwriting files."),Object(i.b)("li",{parentName:"ol"},"Updating your import map to point to the newly deployed file.")),Object(i.b)("p",null,"The implementation of Step 1 is dependent on the infrastructure you're using for your CDN. The AWS CLI (",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.aws.amazon.com/cli/latest/reference/s3/"}),Object(i.b)("inlineCode",{parentName:"a"},"aws s3 sync")),"), Google gsutil (",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/single-spa/import-map-deployer/blob/master/examples/ci-for-javascript-repo/gitlab-gcp-storage/.gitlab-ci.yml"}),Object(i.b)("inlineCode",{parentName:"a"},"gsutil cp")),"), etc are easy ways of accomplishing this."),Object(i.b)("p",null,"For the implementation of Step 2, you have a choice:"),Object(i.b)("p",null,"a) Your CI makes a ",Object(i.b)("inlineCode",{parentName:"p"},"curl")," HTTP call to a running instance of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/single-spa/import-map-deployer"}),"import-map-deployer"),", which updates the import map in a concurrent-safe way.\nb) Your CI runner pulls down the import map, modify it, and reuploads it."),Object(i.b)("p",null,"The advantage of a) is that it is concurrent-safe for multiple, simultaneous deployments. Without a concurrent-safe solution, there might be multiple processes pulling down and reuploading the import map at the same time, which could result in a race condition where one CI process thinks it successfully updated the import map when in reality the other CI process wrote the import map later, having based its changes on a stale version of the import map."),Object(i.b)("p",null,"The advantage of b) is that it doesn't require running the import-map-deployer in your production environment. Ultimately, you should choose whichever option makes sense for your organization."),Object(i.b)("p",null,"The advantage of b) is that it doesn't require running the import-map-deployer in your production environment. Ultimately, you should choose whichever option makes sense for your organization."),Object(i.b)("h2",{id:"applications-versus-parcels-versus-utility-modules"},"Applications versus parcels versus utility modules"),Object(i.b)("p",null,"Single-spa has ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/microfrontends-concept#types-of-microfrontends"}),"different categories")," of microfrontends. It is up to you where and how you use each of them. However, the single-spa core team recommends the following:"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Many route-based single-spa applications, very few single-spa parcels")),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Prefer splitting microfrontends by route, instead of by components within a route. This means preferring single-spa applications over single-spa parcels whenever possible. The reason for this is that transitions between routes often involve destroying and recreating most UI state, which means your single-spa applications on different routes do not need to ever share UI state."),Object(i.b)("li",{parentName:"ol"},"Move fixed navigation menus into their own single-spa applications. Implement their ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"/docs/configuration#activity-function"}),"activity functions")," to be active by default, only unmounting for the login page."),Object(i.b)("li",{parentName:"ol"},"Create utility modules for your core component library / styleguide, for shared authentication / authorization code, and for global error handling."),Object(i.b)("li",{parentName:"ol"},"If you are only using one framework, prefer framework components (i.e. React, Vue, and Angular components) over single-spa parcels. This is because framework components interop easier with each other than when there is an intermediate layer of single-spa parcels. You can import components between single-spa applications You should only create a single-spa parcel if you need it to work with multiple frameworks.")),Object(i.b)("h2",{id:"inter-app-communication"},"Inter-app communication"),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"A good architecture is one in which microfrontends are decoupled and do not need to frequently communicate. Following the guidelines above about applications versus parcels helps you keep your microfrontends decoupled. Route-based single-spa applications inherently require less inter-app communication.")),Object(i.b)("p",null,"There are three things that microfrontends might need to share / communicate:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Functions, components, logic, and environment variables."),Object(i.b)("li",{parentName:"ol"},"API data"),Object(i.b)("li",{parentName:"ol"},"UI state")),Object(i.b)("h3",{id:"functions-components-logic-and-environment-variables"},"Functions, components, logic, and environment variables"),Object(i.b)("p",null,"Example - ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/vue-microfrontends/styleguide/blob/af3eaa70bec7daa74635eb3ec76140fb647b0b14/src/vue-mf-styleguide.js#L5"}),"exporting a shared component")," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/vue-microfrontends/rate-dogs/blob/fe3196234b9cbd6d627199b03a96e7b5f0285c4b/src/components/rate-dogs.vue#L25"}),"importing a shared component"),"."),Object(i.b)("p",null,"You can import and export functions, components, logic, and environment variables between your microfrontends that are in different git repos and javascript bundles:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"// Inside of a utility module called @org-name/auth\nexport function userHasAccess(permission) {\n  return loggedInUser.permissions.some(p => p === permission);\n}\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"import { userHasAccess } from '@org-name/auth'\n\n// Inside of a single-spa application, import and use a util function from a different microfrontend\nconst showLinkToInvoiceFeature = userHasAccess('invoicing');\n")),Object(i.b)("h3",{id:"api-data"},"API Data"),Object(i.b)("p",null,"Example - ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/react-microfrontends/api/blob/c3c336129e920bbc6137f04cce24b718105efed1/src/react-mf-api.js#L3"}),"exporting a ",Object(i.b)("inlineCode",{parentName:"a"},"fetchWithCache")," function")," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/react-microfrontends/people/blob/ad18de9b96b52e6975244e6662becfe13e41a2db/src/utils/api.js#L1"}),"importing the function"),"."),Object(i.b)("p",null,"API data often does not need to be shared between microfrontends, since each single-spa application controls different routes and different routes often have different data. However, occasionally you do need to share API data between microfrontends. An in-memory javascript cache of API objects is a solution used by several companies to solve this. For React users, this is similar to Data Fetching with Suspense, where the fetching logic for routes is split out from the component code that uses the data."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"// Inside of your api utility module, you can lazily fetch data either when another microfrontend calls your exported\n// functions, or eagerly fetch it when the route changes.\nlet loggedInUserPromise = fetch('...').then(r => {\n  if (r.ok) {\n    return r.json()\n  } else {\n    throw Error(`Error getting user, server responded with HTTP ${r.status}`)\n  }\n})\n\nexport function getLoggedInUser() {\n  return loggedInUserPromise;\n}\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"import { getLoggedInUser } from '@org-name/api';\n\n// Inside of app1, you can import something from an \"api\" utility module\ngetLoggedInUser().then(user => {\n  console.log('user', user);\n});\n")),Object(i.b)("h3",{id:"ui-state"},"UI State"),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"If two microfrontends are frequently passing state between each other, consider merging them. The disadvantages of microfrontends are enhanced when your microfrontends are not isolated modules.")),Object(i.b)("p",null,'UI State, such as "is the modal open," "what\'s the current value of that input," etc. largely does not need to be shared between microfrontends. If you find yourself needing constant sharing of UI state, your microfrontends are likely more coupled than they should be. Consider merging them into a single microfrontend.'),Object(i.b)("p",null,"Under the rare circumstances where you do need to share UI state between single-spa applications, an event emitter may be used to do so. Below are a few examples of event emitters that might help you out."),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Observables / Subjects (rxjs) - one microfrontend emits new values to a stream that can be consumed by any other microfrontend. It exports the observable to all microfrontends from its in-browser module, so that others may import it."),Object(i.b)("li",{parentName:"ol"},"CustomEvents - browsers have a built-in event emitter system that allows you to fire custom events. Check out ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events"}),"this documentation")," for more information. Firing the events with ",Object(i.b)("inlineCode",{parentName:"li"},"window.dispatchEvent")," allows you to subscribe in any other microfrontend with ",Object(i.b)("inlineCode",{parentName:"li"},"window.addEventListener"),"."),Object(i.b)("li",{parentName:"ol"},"Any other pub/sub event emitter system.")),Object(i.b)("h2",{id:"state-management"},"State management"),Object(i.b)("p",null,"The single-spa core team cautions against using redux, mobx, and other global state management libraries. However, if you'd like to use a state management library, we recommend keeping the state management tool specific to a single repository / microfrontend instead of a single store for all of your microfrontends. The reason is that microfrontends are not truly decoupled or framework agnostic if they all must use a global store. You cannot independently deploy a microfrontend if it relies on the global store's state to be a specific shape or have specific actions fired by other microfrontends - to do so you'd have to think really hard about whether your changes to the global store are backwards and forwards compatible with all other microfrontends. Additionally, managing global state during route transitions is hard enough without the complexity of multiple microfrontends contributing to and consuming the global state."),Object(i.b)("p",null,'Instead of a global store, the single-spa core team recommends using local component state for your components, or a store for each of your microfrontends. See the above section "Inter-app communication" for more related information.'))}p.isMDXComponent=!0},360:function(e,t,o){"use strict";o.d(t,"a",(function(){return s})),o.d(t,"b",(function(){return b}));var a=o(0),n=o.n(a),i=n.a.createContext({}),r=function(e){var t=n.a.useContext(i),o=t;return e&&(o="function"==typeof e?e(t):Object.assign({},t,e)),o},s=function(e){var t=r(e.components);return n.a.createElement(i.Provider,{value:t},e.children)};var l="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.a.createElement(n.a.Fragment,{},t)}},p=Object(a.forwardRef)((function(e,t){var o=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,l=function(e,t){var o={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===t.indexOf(a)&&(o[a]=e[a]);return o}(e,["components","mdxType","originalType","parentName"]),p=r(o),b=a,u=p[s+"."+b]||p[b]||c[b]||i;return o?n.a.createElement(u,Object.assign({},{ref:t},l,{components:o})):n.a.createElement(u,Object.assign({},{ref:t},l))}));function b(e,t){var o=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=o.length,r=new Array(i);r[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[l]="string"==typeof e?e:a,r[1]=s;for(var b=2;b<i;b++)r[b]=o[b];return n.a.createElement.apply(null,r)}return n.a.createElement.apply(null,o)}p.displayName="MDXCreateElement"}}]);