(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{146:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return l})),t.d(a,"rightToc",(function(){return c})),t.d(a,"default",(function(){return p}));var n=t(1),i=t(9),r=(t(0),t(297)),l={id:"module-types",title:"single-spa microfrontend types",sidebar_label:"Microfrontend Types"},c=[{value:"Applications",id:"applications",children:[{value:"Applications are declarative",id:"applications-are-declarative",children:[]},{value:"Applications have managed lifecycles",id:"applications-have-managed-lifecycles",children:[]}]},{value:"Parcels",id:"parcels",children:[{value:"Parcels are imperative",id:"parcels-are-imperative",children:[]},{value:"You manage the lifecycles of Parcels",id:"you-manage-the-lifecycles-of-parcels",children:[]},{value:"Parcels are best suited for sharing UI between frameworks",id:"parcels-are-best-suited-for-sharing-ui-between-frameworks",children:[]}]},{value:"Utility modules share common logic",id:"utility-modules-share-common-logic",children:[]}],o={rightToc:c},s="wrapper";function p(e){var a=e.components,t=Object(i.a)(e,["components"]);return Object(r.b)(s,Object(n.a)({},o,t,{components:a,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"concept-single-spa-microfrontend-types"},"Concept: single-spa microfrontend types"),Object(r.b)("p",null,"Single-spa has ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"./microfrontends-concept#types-of-microfrontends.md"}),"different categories")," of microfrontends. It is up to you where and how you use each of them. However, the single-spa core team has ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"./recommended-setup/#applications-versus-parcels-versus-utility-modules.md"}),"recommendations"),"."),Object(r.b)("p",null,"Here is how each single-spa microfrontend works conceptually. This information should help you understand our ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"./recommended-setup/#applications-versus-parcels-versus-utility-modules.md"}),"recommendations"),"."),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Topic"),Object(r.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"application"),Object(r.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"parcel"),Object(r.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"utility"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"routing"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"has multiple routes"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"no routes"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"no routes")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"API"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"declarative API"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"imperative API"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"no single-spa api")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"renders UI"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"renders UI"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"renders UI"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"doesn't directly render UI")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"lifecycles"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"single-spa managed lifecycles"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"custom managed lifecycles"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"no lifecycles")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"When to use"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Core building block"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"only needed with multiple frameworks"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"useful to share common logic")))),Object(r.b)("p",null,"Each single-spa microfrontend is an in-browser javascript module (",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"./recommended-setup#in-browser-versus-build-time-modules.md"}),"explanation"),")."),Object(r.b)("h2",{id:"applications"},"Applications"),Object(r.b)("h3",{id:"applications-are-declarative"},"Applications are declarative"),Object(r.b)("p",null,"Applications use a declarative api called ",Object(r.b)("inlineCode",{parentName:"p"},"registerApplication"),". Your single-spa config (also sometimes called root config) defines applications ahead of time, defines the condition at which they are active, but doesn't mount the application directly."),Object(r.b)("h3",{id:"applications-have-managed-lifecycles"},"Applications have managed lifecycles"),Object(r.b)("p",null,"single-spa manages registered applications and is in charge of all of their lifecycles. This prevents you from writing a bunch of logic about when applications should mount and unmount; single-spa takes care of that for you.\nAll single spa needs to make this work automatically is for an activity function that describes when your application should be active."),Object(r.b)("h2",{id:"parcels"},"Parcels"),Object(r.b)("h3",{id:"parcels-are-imperative"},"Parcels are imperative"),Object(r.b)("p",null,"Parcels exist in many ways as an escape hatch from the normal declarative flow. They exist primarily to allow you to reuse UI across applications when those applications are written in multiple frameworks."),Object(r.b)("h3",{id:"you-manage-the-lifecycles-of-parcels"},"You manage the lifecycles of Parcels"),Object(r.b)("p",null,"When you call ",Object(r.b)("inlineCode",{parentName:"p"},"mountParcel")," or ",Object(r.b)("inlineCode",{parentName:"p"},"mountRootParcel")," ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/parcels-api"}),"(see api)")," the parcel is mounted immediately and returns the parcel object. You need to call the ",Object(r.b)("inlineCode",{parentName:"p"},"unmount")," method on the parcel manually when the component that calls ",Object(r.b)("inlineCode",{parentName:"p"},"mountParcel")," unmounts."),Object(r.b)("h3",{id:"parcels-are-best-suited-for-sharing-ui-between-frameworks"},"Parcels are best suited for sharing UI between frameworks"),Object(r.b)("p",null,"Creating a parcel is as easy as using the ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"./ecosystem#help-for-frameworks.md"}),"single-spa helpers")," for that framework on a specific component/UI. This returns an object (",Object(r.b)("inlineCode",{parentName:"p"},"parcelConfig"),") that single-spa can use to create and mount a parcel.\nBecause single-spa can mount a parcel anywhere, this gives you a way to share UI/components across frameworks. It should not be used if the shared UI is being used in another application of the same framework.\nFor example: ",Object(r.b)("inlineCode",{parentName:"p"},"applicationOne")," is written in Vue and contains all the UI/Logic to create a user. ",Object(r.b)("inlineCode",{parentName:"p"},"application2")," is written in React and needs to create a user. Using a single-spa parcel allows you to wrap your ",Object(r.b)("inlineCode",{parentName:"p"},"app1")," Vue component\nin a way that will make it work inside ",Object(r.b)("inlineCode",{parentName:"p"},"application2")," despite the different frameworks. Even better if ",Object(r.b)("inlineCode",{parentName:"p"},"application2")," is unmounted by single-spa (per the activity function returning false)\nThink of parcels as a single-spa specific implementation of webcomponents."),Object(r.b)("h2",{id:"utility-modules-share-common-logic"},"Utility modules share common logic"),Object(r.b)("p",null,"Utility modules are a great place to share common logic. Instead of each application creating their own implementation of common logic, you can use a plain javascript object (single-spa utility) to share that logic.\nFor example: Authorization. How does each application know which user is logged in? You could have each application ask the server or read a JWT but that creates duplicate work in each application.\nUsing Utility modules you can implement logic around who is logged in one module (with all the necessary methods exported on the module) and each single-spa application can use the logic by importing the methods from the utilty module.\nThis approach also works well for data ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"./recommended-setup#api-data.md"}),"fetching"),"."))}p.isMDXComponent=!0},297:function(e,a,t){"use strict";t.d(a,"a",(function(){return c})),t.d(a,"b",(function(){return b}));var n=t(0),i=t.n(n),r=i.a.createContext({}),l=function(e){var a=i.a.useContext(r),t=a;return e&&(t="function"==typeof e?e(a):Object.assign({},a,e)),t},c=function(e){var a=l(e.components);return i.a.createElement(r.Provider,{value:a},e.children)};var o="mdxType",s={inlineCode:"code",wrapper:function(e){var a=e.children;return i.a.createElement(i.a.Fragment,{},a)}},p=Object(n.forwardRef)((function(e,a){var t=e.components,n=e.mdxType,r=e.originalType,c=e.parentName,o=function(e,a){var t={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&-1===a.indexOf(n)&&(t[n]=e[n]);return t}(e,["components","mdxType","originalType","parentName"]),p=l(t),b=n,m=p[c+"."+b]||p[b]||s[b]||r;return t?i.a.createElement(m,Object.assign({},{ref:a},o,{components:t})):i.a.createElement(m,Object.assign({},{ref:a},o))}));function b(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var r=t.length,l=new Array(r);l[0]=p;var c={};for(var s in a)hasOwnProperty.call(a,s)&&(c[s]=a[s]);c.originalType=e,c[o]="string"==typeof e?e:n,l[1]=c;for(var b=2;b<r;b++)l[b]=t[b];return i.a.createElement.apply(null,l)}return i.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);